---
title: "Logging Best Practices"
description: "Learn the best practices for implementing effective logging in your applications with BoxLog."
tags: ["best-practices", "logging", "guide", "performance"]
author: "BoxLog Team"
publishedAt: "2025-01-16"
updatedAt: "2025-01-16"
order: 1
featured: true
category: "guides"
slug: "best-practices"
---

# Logging Best Practices

Effective logging is crucial for debugging, monitoring, and maintaining healthy applications. This guide covers best practices for implementing logging with BoxLog.

## 1. Log Levels Guidelines

Use appropriate log levels to make your logs meaningful and actionable:

### When to Use Each Level

```javascript
// TRACE - Detailed execution flow
logger.trace('Entering processPayment function', { orderId, amount })

// DEBUG - Detailed information for debugging
logger.debug('Payment validation passed', { validationRules, result })

// INFO - Important business events
logger.info('Payment processed successfully', { orderId, amount, customerId })

// WARN - Potentially harmful situations
logger.warn('Payment retry attempted', { orderId, attempt: 3, maxAttempts: 5 })

// ERROR - Error events that might still allow the app to continue
logger.error('Payment failed', { orderId, error: err.message, stack: err.stack })

// FATAL - Severe errors that might cause the app to abort
logger.fatal('Database connection lost', { error: err.message })
```

## 2. Structured Logging

Always use structured logging instead of plain text messages:

```javascript
// ❌ Bad - Unstructured log
logger.info(`User ${userId} logged in from ${ipAddress}`)

// ✅ Good - Structured log
logger.info('User login', {
  userId,
  ipAddress,
  userAgent,
  timestamp: new Date().toISOString()
})
```

### Benefits of Structured Logging
- Easier to search and filter
- Better for analytics and aggregation
- Machine-readable for automated processing
- Consistent format across services

## 3. Contextual Information

Include relevant context in every log entry:

```javascript
// Create a logger with default context
const logger = new BoxLog({
  apiKey: process.env.BOXLOG_API_KEY,
  defaultMetadata: {
    service: 'payment-service',
    environment: process.env.NODE_ENV,
    version: process.env.APP_VERSION
  }
})

// Add request-specific context
app.use((req, res, next) => {
  req.logger = logger.child({
    requestId: req.id,
    userId: req.user?.id,
    path: req.path,
    method: req.method
  })
  next()
})
```

## 4. Performance Considerations

### Sampling High-Volume Logs

For high-frequency events, use sampling to reduce volume:

```javascript
// Sample 10% of trace logs
if (Math.random() < 0.1) {
  logger.trace('High frequency event', { /* data */ })
}

// Or use built-in sampling
const sampledLogger = logger.withSampling({
  trace: 0.1,  // 10% of trace logs
  debug: 0.5,  // 50% of debug logs
  info: 1.0    // 100% of info and above
})
```

### Async Logging

Use async logging to avoid blocking your application:

```javascript
// Configure async batch sending
const logger = new BoxLog({
  apiKey: process.env.BOXLOG_API_KEY,
  batchSize: 100,
  flushInterval: 5000 // 5 seconds
})

// Logs are queued and sent in batches
logger.info('This log is queued', { data })
```

## 5. Security and Privacy

### Never Log Sensitive Data

```javascript
// ❌ Bad - Logging sensitive information
logger.info('User login', {
  email: user.email,
  password: user.password,  // Never log passwords!
  creditCard: user.creditCard  // Never log credit cards!
})

// ✅ Good - Sanitize sensitive data
logger.info('User login', {
  email: user.email,
  userId: user.id,
  hasPassword: !!user.password,
  paymentMethod: 'card_****1234'
})
```

### Use Data Masking

Implement automatic data masking for sensitive fields:

```javascript
const logger = new BoxLog({
  apiKey: process.env.BOXLOG_API_KEY,
  masks: [
    { field: 'password', mask: '[REDACTED]' },
    { field: 'creditCard', mask: (value) => `****${value.slice(-4)}` },
    { field: 'ssn', mask: 'XXX-XX-****' }
  ]
})
```

## 6. Error Logging

### Include Stack Traces

Always include stack traces for errors:

```javascript
try {
  await riskyOperation()
} catch (error) {
  logger.error('Operation failed', {
    error: {
      message: error.message,
      stack: error.stack,
      code: error.code
    },
    operation: 'riskyOperation',
    context: { /* relevant context */ }
  })
}
```

### Use Error Boundaries

In React applications, use error boundaries:

```jsx
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    logger.error('React error boundary triggered', {
      error: error.toString(),
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      props: this.props
    })
  }
}
```

## 7. Correlation and Tracing

### Use Trace IDs

Implement distributed tracing with correlation IDs:

```javascript
// Generate trace ID at the entry point
app.use((req, res, next) => {
  req.traceId = req.headers['x-trace-id'] || generateTraceId()
  req.logger = logger.child({ traceId: req.traceId })
  res.setHeader('x-trace-id', req.traceId)
  next()
})

// Pass trace ID to downstream services
const response = await fetch(serviceUrl, {
  headers: {
    'x-trace-id': req.traceId
  }
})
```

## 8. Monitoring and Alerting

### Set Up Meaningful Alerts

Configure alerts for critical issues:

```javascript
// Log with alert metadata
logger.error('Database connection pool exhausted', {
  alert: true,
  alertChannel: 'database-team',
  currentConnections: pool.size,
  maxConnections: pool.max,
  waitingRequests: pool.pending
})
```

### Track Key Metrics

Log business metrics for monitoring:

```javascript
// Log business metrics
logger.info('Order completed', {
  metric: 'order_completed',
  amount: order.total,
  currency: order.currency,
  paymentMethod: order.paymentMethod,
  processingTime: Date.now() - startTime
})
```

## 9. Development vs Production

### Environment-Specific Configuration

```javascript
const logger = new BoxLog({
  apiKey: process.env.BOXLOG_API_KEY,
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  pretty: process.env.NODE_ENV !== 'production',
  includeStackTrace: process.env.NODE_ENV !== 'production'
})
```

### Local Development

For local development, use console output:

```javascript
if (process.env.NODE_ENV === 'development') {
  logger.addTransport('console', {
    pretty: true,
    colors: true
  })
}
```

## 10. Log Retention and Costs

### Implement Log Rotation

Configure appropriate retention policies:

```javascript
const logger = new BoxLog({
  apiKey: process.env.BOXLOG_API_KEY,
  retention: {
    trace: '1d',    // 1 day
    debug: '3d',    // 3 days
    info: '30d',    // 30 days
    warn: '90d',    // 90 days
    error: '1y',    // 1 year
    fatal: '2y'     // 2 years
  }
})
```

### Cost Optimization

- Use appropriate log levels
- Implement sampling for high-volume logs
- Regularly review and clean up unnecessary logging
- Use log aggregation for metrics instead of individual events

## Summary

Effective logging is a balance between having enough information for debugging and maintaining performance. Follow these best practices to build a robust logging strategy that scales with your application.

## Next Steps

- [Performance Optimization](/docs/guides/performance) - Optimize your logging performance
- [Security Guidelines](/docs/guides/security) - Secure your logs
- [Monitoring Guide](/docs/guides/monitoring) - Set up effective monitoring