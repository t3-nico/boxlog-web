---
title: "SaaSアプリケーションのためのデータベース設計指針"
description: "マルチテナント対応、スケーラビリティ、セキュリティを考慮したSaaSアプリケーションのデータベース設計について詳しく解説します。PostgreSQLとPrismaを使った実装例も紹介します。"
publishedAt: "2024-01-12"
updatedAt: "2024-01-25"
tags: ["データベース", "SaaS", "PostgreSQL", "設計", "スケーラビリティ", "セキュリティ"]
category: "技術"
author: "田中 恵子"
authorAvatar: "/avatars/keiko-tanaka.jpg"
coverImage: "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2070&q=80"
featured: true
draft: false
---

# SaaSアプリケーションのためのデータベース設計指針

SaaSアプリケーションの成功において、データベース設計は極めて重要な要素です。適切な設計により、スケーラビリティ、セキュリティ、パフォーマンスを確保できる一方、不適切な設計は将来的な成長の障壁となります。

本記事では、実際のプロダクション環境で運用されているSaaSアプリケーションの経験をもとに、データベース設計のベストプラクティスを詳しく解説します。

## マルチテナント戦略の選択

SaaSアプリケーションにおける最初の重要な決断は、マルチテナント戦略の選択です。

### 1. データベース分離レベルの比較

| 戦略 | セキュリティ | コスト | 管理複雑度 | スケーラビリティ |
|------|-------------|--------|------------|-----------------|
| データベース分離 | ★★★★★ | ★★☆☆☆ | ★★★★☆ | ★★★☆☆ |
| スキーマ分離 | ★★★★☆ | ★★★☆☆ | ★★★☆☆ | ★★★★☆ |
| 行レベル分離 | ★★★☆☆ | ★★★★★ | ★★★★★ | ★★★★★ |

### 2. 行レベル分離の実装

最も一般的で費用対効果の高い行レベル分離の実装例を見てみましょう：

```sql
-- テナント管理テーブル
CREATE TABLE tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  subdomain VARCHAR(100) UNIQUE NOT NULL,
  plan_type VARCHAR(50) NOT NULL DEFAULT 'free',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE,
  
  -- 設定情報
  settings JSONB DEFAULT '{}',
  
  -- 使用量制限
  max_users INTEGER DEFAULT 5,
  max_storage_gb INTEGER DEFAULT 1,
  
  CONSTRAINT valid_subdomain 
    CHECK (subdomain ~ '^[a-z0-9][a-z0-9-]*[a-z0-9]$')
);

-- ユーザーテーブル
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  email VARCHAR(255) NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  role VARCHAR(50) NOT NULL DEFAULT 'user',
  
  -- プロファイル情報
  first_name VARCHAR(100),
  last_name VARCHAR(100),
  avatar_url TEXT,
  
  -- 状態管理
  is_active BOOLEAN DEFAULT TRUE,
  email_verified_at TIMESTAMP WITH TIME ZONE,
  last_login_at TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(tenant_id, email)
);

-- プロジェクトテーブル
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  
  -- プロジェクト設定
  settings JSONB DEFAULT '{}',
  
  -- 状態管理
  status VARCHAR(50) DEFAULT 'active',
  archived_at TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_by UUID REFERENCES users(id)
);
```

### 3. Row Level Security (RLS) の実装

PostgreSQLのRLSを活用してテナント分離を強化：

```sql
-- RLSを有効化
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;

-- ユーザー用のポリシー
CREATE POLICY tenant_isolation_users ON users
  USING (tenant_id = current_setting('app.current_tenant_id')::UUID);

-- プロジェクト用のポリシー
CREATE POLICY tenant_isolation_projects ON projects
  USING (tenant_id = current_setting('app.current_tenant_id')::UUID);

-- 管理者用のバイパスポリシー
CREATE POLICY admin_bypass_users ON users
  TO admin_role
  USING (true);
```

## スケーラブルなスキーマ設計

### 1. 効率的なインデックス戦略

```sql
-- 複合インデックスの作成
CREATE INDEX idx_users_tenant_email ON users(tenant_id, email);
CREATE INDEX idx_projects_tenant_status ON projects(tenant_id, status);
CREATE INDEX idx_projects_created_at ON projects(created_at DESC);

-- 部分インデックス（条件付きインデックス）
CREATE INDEX idx_active_users 
ON users(tenant_id, email) 
WHERE is_active = TRUE;

-- 式インデックス
CREATE INDEX idx_users_email_lower 
ON users(tenant_id, LOWER(email));

-- GINインデックス（JSON検索用）
CREATE INDEX idx_tenant_settings 
ON tenants USING GIN(settings);
```

### 2. パーティショニング戦略

時系列データの効率的な管理：

```sql
-- ログテーブルのパーティショニング
CREATE TABLE audit_logs (
  id UUID DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL,
  user_id UUID,
  action VARCHAR(100) NOT NULL,
  resource_type VARCHAR(100),
  resource_id UUID,
  details JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- 月ごとのパーティション作成
CREATE TABLE audit_logs_2024_01 
PARTITION OF audit_logs
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE audit_logs_2024_02 
PARTITION OF audit_logs
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- 自動パーティション作成関数
CREATE OR REPLACE FUNCTION create_monthly_partition(table_name TEXT, start_date DATE)
RETURNS VOID AS $$
DECLARE
  partition_name TEXT;
  end_date DATE;
BEGIN
  partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');
  end_date := start_date + INTERVAL '1 month';
  
  EXECUTE format(
    'CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
    partition_name, table_name, start_date, end_date
  );
END;
$$ LANGUAGE plpgsql;
```

## 使用量制限とリソース管理

### 1. テナント別使用量追跡

```sql
-- 使用量追跡テーブル
CREATE TABLE usage_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  metric_name VARCHAR(100) NOT NULL,
  metric_value BIGINT NOT NULL,
  measured_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- メタデータ
  metadata JSONB DEFAULT '{}',
  
  UNIQUE(tenant_id, metric_name, measured_at)
);

-- 使用量集計ビュー
CREATE VIEW tenant_usage_summary AS
SELECT 
  t.id as tenant_id,
  t.name as tenant_name,
  t.plan_type,
  COALESCE(um_users.metric_value, 0) as current_users,
  t.max_users,
  COALESCE(um_storage.metric_value, 0) as storage_used_mb,
  (t.max_storage_gb * 1024) as storage_limit_mb,
  CASE 
    WHEN COALESCE(um_users.metric_value, 0) >= t.max_users THEN true
    WHEN COALESCE(um_storage.metric_value, 0) >= (t.max_storage_gb * 1024) THEN true
    ELSE false
  END as is_over_limit
FROM tenants t
LEFT JOIN LATERAL (
  SELECT metric_value 
  FROM usage_metrics 
  WHERE tenant_id = t.id 
    AND metric_name = 'active_users'
  ORDER BY measured_at DESC 
  LIMIT 1
) um_users ON true
LEFT JOIN LATERAL (
  SELECT metric_value 
  FROM usage_metrics 
  WHERE tenant_id = t.id 
    AND metric_name = 'storage_used_mb'
  ORDER BY measured_at DESC 
  LIMIT 1
) um_storage ON true;
```

### 2. プラン制限の実装

```sql
-- プラン定義テーブル
CREATE TABLE subscription_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL UNIQUE,
  display_name VARCHAR(255) NOT NULL,
  
  -- 制限値
  max_users INTEGER NOT NULL,
  max_storage_gb INTEGER NOT NULL,
  max_projects INTEGER NOT NULL,
  max_api_calls_per_month INTEGER NOT NULL,
  
  -- 機能フラグ
  features JSONB NOT NULL DEFAULT '{}',
  
  -- 価格情報
  price_monthly_cents INTEGER,
  price_annual_cents INTEGER,
  
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- プラン別機能チェック関数
CREATE OR REPLACE FUNCTION check_feature_access(
  p_tenant_id UUID,
  p_feature_name TEXT
) RETURNS BOOLEAN AS $$
DECLARE
  has_access BOOLEAN := FALSE;
BEGIN
  SELECT 
    COALESCE(sp.features->p_feature_name, 'false')::BOOLEAN
  INTO has_access
  FROM tenants t
  JOIN subscription_plans sp ON sp.name = t.plan_type
  WHERE t.id = p_tenant_id;
  
  RETURN COALESCE(has_access, FALSE);
END;
$$ LANGUAGE plpgsql;
```

## セキュリティとコンプライアンス

### 1. データ暗号化

```sql
-- 機密データ用の暗号化テーブル
CREATE TABLE encrypted_secrets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  key_name VARCHAR(255) NOT NULL,
  
  -- 暗号化されたデータ
  encrypted_value BYTEA NOT NULL,
  encryption_key_id VARCHAR(255) NOT NULL,
  
  -- メタデータ
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_by UUID REFERENCES users(id),
  
  UNIQUE(tenant_id, key_name)
);

-- 暗号化関数の例（実際はアプリケーション層で実装）
CREATE OR REPLACE FUNCTION encrypt_secret(
  p_tenant_id UUID,
  p_key_name VARCHAR(255),
  p_plaintext TEXT,
  p_created_by UUID
) RETURNS UUID AS $$
DECLARE
  secret_id UUID;
BEGIN
  -- 実際の暗号化はアプリケーション層で行う
  INSERT INTO encrypted_secrets (
    tenant_id, key_name, encrypted_value, 
    encryption_key_id, created_by
  ) VALUES (
    p_tenant_id, p_key_name, 
    -- pgcryptoを使用した例（本番では外部KMSを推奨）
    pgp_sym_encrypt(p_plaintext, current_setting('app.encryption_key')),
    'app_key_v1', p_created_by
  ) RETURNING id INTO secret_id;
  
  RETURN secret_id;
END;
$$ LANGUAGE plpgsql;
```

### 2. 監査ログの実装

```sql
-- 包括的な監査ログ
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  
  -- ユーザー情報
  user_id UUID REFERENCES users(id),
  user_email VARCHAR(255),
  
  -- アクション詳細
  action VARCHAR(100) NOT NULL, -- CREATE, UPDATE, DELETE, LOGIN, etc.
  resource_type VARCHAR(100) NOT NULL, -- user, project, file, etc.
  resource_id UUID,
  resource_name VARCHAR(255),
  
  -- 変更詳細
  old_values JSONB,
  new_values JSONB,
  
  -- リクエスト情報
  ip_address INET,
  user_agent TEXT,
  request_id UUID,
  
  -- メタデータ
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- 監査ログ作成のトリガー関数
CREATE OR REPLACE FUNCTION create_audit_log()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO audit_logs (
    tenant_id, user_id, action, resource_type, 
    resource_id, old_values, new_values
  ) VALUES (
    COALESCE(NEW.tenant_id, OLD.tenant_id),
    current_setting('app.current_user_id', true)::UUID,
    TG_OP,
    TG_TABLE_NAME,
    COALESCE(NEW.id, OLD.id),
    to_jsonb(OLD),
    to_jsonb(NEW)
  );
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- トリガーの適用
CREATE TRIGGER audit_users_trigger
  AFTER INSERT OR UPDATE OR DELETE ON users
  FOR EACH ROW EXECUTE FUNCTION create_audit_log();
```

## Prismaスキーマの実装

実際のアプリケーションで使用するPrismaスキーマ：

```prisma
// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Tenant {
  id        String   @id @default(cuid())
  name      String
  subdomain String   @unique
  planType  String   @default("free") @map("plan_type")
  
  // 設定
  settings Json @default("{}")
  
  // 制限
  maxUsers     Int @default(5) @map("max_users")
  maxStorageGb Int @default(1) @map("max_storage_gb")
  
  // ステータス
  isActive  Boolean   @default(true) @map("is_active")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  
  // リレーション
  users         User[]
  projects      Project[]
  usageMetrics  UsageMetric[]
  auditLogs     AuditLog[]
  
  @@map("tenants")
}

model User {
  id       String @id @default(cuid())
  tenantId String @map("tenant_id")
  email    String
  
  // 認証
  passwordHash String @map("password_hash")
  role         String @default("user")
  
  // プロファイル
  firstName String? @map("first_name")
  lastName  String? @map("last_name")
  avatarUrl String? @map("avatar_url")
  
  // ステータス
  isActive         Boolean   @default(true) @map("is_active")
  emailVerifiedAt  DateTime? @map("email_verified_at")
  lastLoginAt      DateTime? @map("last_login_at")
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // リレーション
  tenant        Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdProjects Project[] @relation("ProjectCreator")
  auditLogs     AuditLog[]
  
  @@unique([tenantId, email])
  @@map("users")
}

model Project {
  id          String  @id @default(cuid())
  tenantId    String  @map("tenant_id")
  name        String
  description String?
  
  // 設定
  settings Json @default("{}") 
  
  // ステータス
  status     String    @default("active")
  archivedAt DateTime? @map("archived_at")
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by")
  
  // リレーション
  tenant  Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  creator User?  @relation("ProjectCreator", fields: [createdBy], references: [id])
  
  @@map("projects")
}

model UsageMetric {
  id          String   @id @default(cuid())
  tenantId    String   @map("tenant_id")
  metricName  String   @map("metric_name")
  metricValue BigInt   @map("metric_value")
  measuredAt  DateTime @default(now()) @map("measured_at")
  
  // メタデータ
  metadata Json @default("{}")
  
  // リレーション
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  @@unique([tenantId, metricName, measuredAt])
  @@map("usage_metrics")
}

model AuditLog {
  id           String    @id @default(cuid())
  tenantId     String    @map("tenant_id")
  userId       String?   @map("user_id")
  action       String
  resourceType String    @map("resource_type")
  resourceId   String?   @map("resource_id")
  
  // 変更詳細
  oldValues Json? @map("old_values")
  newValues Json? @map("new_values")
  
  // リクエスト情報
  ipAddress String? @map("ip_address")
  userAgent String? @map("user_agent")
  
  // メタデータ
  metadata Json @default("{}")
  
  createdAt DateTime @default(now()) @map("created_at")
  
  // リレーション
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id])
  
  @@map("audit_logs")
}
```

## パフォーマンス最適化

### 1. クエリ最適化のベストプラクティス

```typescript
// 効率的なクエリの例
class TenantService {
  async getTenantWithUsers(tenantId: string) {
    return await prisma.tenant.findUnique({
      where: { id: tenantId },
      include: {
        users: {
          where: { isActive: true },
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
            lastLoginAt: true,
          },
          orderBy: { createdAt: 'desc' },
        },
        _count: {
          select: {
            projects: true,
            users: true,
          },
        },
      },
    })
  }

  // バッチ処理での最適化
  async getTenantsUsage(tenantIds: string[]) {
    const [tenants, usageMetrics] = await Promise.all([
      prisma.tenant.findMany({
        where: { id: { in: tenantIds } },
        select: {
          id: true,
          name: true,
          planType: true,
          maxUsers: true,
          maxStorageGb: true,
        },
      }),
      prisma.usageMetric.findMany({
        where: {
          tenantId: { in: tenantIds },
          metricName: { in: ['active_users', 'storage_used_mb'] },
        },
        orderBy: { measuredAt: 'desc' },
        distinct: ['tenantId', 'metricName'],
      }),
    ])

    // データの結合処理
    return tenants.map(tenant => {
      const userUsage = usageMetrics.find(
        m => m.tenantId === tenant.id && m.metricName === 'active_users'
      )
      const storageUsage = usageMetrics.find(
        m => m.tenantId === tenant.id && m.metricName === 'storage_used_mb'
      )

      return {
        ...tenant,
        currentUsers: userUsage?.metricValue || 0,
        storageUsedMb: storageUsage?.metricValue || 0,
        isOverLimit: 
          (userUsage?.metricValue || 0) >= tenant.maxUsers ||
          (storageUsage?.metricValue || 0) >= (tenant.maxStorageGb * 1024),
      }
    })
  }
}
```

### 2. 接続プールとキャッシュ戦略

```typescript
// 接続プール設定
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
  // 接続プール設定
  // connection_limit=10&pool_timeout=30
})

// Redis キャッシュの実装
class CacheService {
  private redis: Redis

  async getTenantCached(tenantId: string): Promise<Tenant | null> {
    const cacheKey = `tenant:${tenantId}`
    
    // キャッシュから取得
    const cached = await this.redis.get(cacheKey)
    if (cached) {
      return JSON.parse(cached)
    }

    // DBから取得
    const tenant = await prisma.tenant.findUnique({
      where: { id: tenantId },
    })

    if (tenant) {
      // キャッシュに保存（5分間）
      await this.redis.setex(cacheKey, 300, JSON.stringify(tenant))
    }

    return tenant
  }

  async invalidateTenantCache(tenantId: string): Promise<void> {
    await this.redis.del(`tenant:${tenantId}`)
  }
}
```

## まとめ

SaaSアプリケーションのデータベース設計では、以下の要素が重要です：

### 設計の基本原則

1. **マルチテナント戦略**: 要件に応じた適切な分離レベルの選択
2. **スケーラビリティ**: パーティショニングとインデックス戦略
3. **セキュリティ**: RLS、暗号化、監査ログの実装
4. **パフォーマンス**: 効率的なクエリと適切なキャッシュ戦略

### 実装時の注意点

<Callout type="info">
データベース設計は後からの変更が困難です。初期段階で以下を慎重に検討してください：

- **データモデルの正規化**: 適切な正規化レベルの選択
- **インデックス戦略**: クエリパターンに基づく設計
- **監査要件**: コンプライアンス要求事項の確認
- **拡張性**: 将来の成長を見据えた設計
</Callout>

### 継続的な最適化

1. **監視とメトリクス**: クエリパフォーマンスの継続的な監視
2. **インデックス最適化**: 使用パターンに基づく調整
3. **容量計画**: 成長予測に基づくリソース計画
4. **セキュリティ監査**: 定期的なセキュリティレビュー

適切なデータベース設計により、スケーラブルで安全なSaaSアプリケーションの基盤を構築できます。要件の変化に応じて継続的に最適化を行い、長期的な成功を目指しましょう。